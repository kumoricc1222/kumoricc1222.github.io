<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8" />
<title>單只因 Set</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
:root{--card-w:110px;--card-h:130px}
body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", sans-serif; text-align: center; background: #fafafa; margin:0; padding:20px }
#game { max-width: 980px; margin: 0 auto; }
.board { display: grid; grid-template-columns: repeat(6, var(--card-w)); gap: 8px; justify-content:center }
.card { width: var(--card-w); height: var(--card-h); border: 2px solid #d0d6da; background: #fff; border-radius: 10px; cursor: pointer; display:flex; align-items:center; justify-content:center; padding:8px; box-sizing:border-box; transition: transform 220ms ease, box-shadow 220ms ease, border-color 220ms ease; position:relative; overflow: hidden; user-select:none; -webkit-tap-highlight-color: transparent; touch-action: manipulation; z-index:1; }
.card.empty{ background: #f6f8fa; border-style: dashed; opacity:0.6; cursor:default }
.card svg{ width: 72px; display:block; pointer-events: none }
.card svg *{ pointer-events: none }
.card.selected{ transform: translateY(-10px); box-shadow: 0 12px 30px rgba(30,136,255,0.22), 0 0 0 6px rgba(30,136,255,0.06) inset; border-color: #1976d2; z-index: 10; }
.card.hint{ animation: pulse 900ms ease-in-out; border-color: #ffb300; box-shadow: 0 12px 28px rgba(255,179,0,0.14); z-index:9 }
@keyframes pulse{ 0%{ transform: translateY(0) scale(1) } 50%{ transform: translateY(-6px) scale(1.02) } 100%{ transform: translateY(0) scale(1) } }
.card.new{ animation: dealIn 320ms ease forwards; }
@keyframes dealIn{ from{ transform: translateY(-18px) scale(0.96); opacity:0 } to{ transform: translateY(0) scale(1); opacity:1 } }
.card.removing{ animation: removeOut 300ms ease forwards; }
@keyframes removeOut{ to{ transform: translateY(18px) scale(0.85); opacity:0 } }
#controls { margin: 14px 0 18px 0; display:flex; gap:8px; align-items:center; justify-content:center; flex-wrap:wrap }
#controls button{ padding:8px 12px; border-radius:8px; border:1px solid #bfc8d2; background:#fff; cursor:pointer }
#controls span{ margin-left:6px }
#scoreboard { margin-top: 18px; }
table { border-collapse: collapse; margin: auto; width:100%; max-width:980px }
td, th { border: 1px solid #e0e6ea; padding: 6px 8px; text-align:center }
.modal-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,0.45); display:flex; align-items:center; justify-content:center; z-index:9999; }
.modal{ background:#fff; border-radius:12px; padding:22px; width: min(560px, 92%); box-shadow: 0 20px 40px rgba(0,0,0,0.25); text-align:center }
.modal h2{ margin:0 0 8px 0; font-size:24px }
.modal p{ margin:8px 0 16px 0; font-size:18px }
.modal .actions{ display:flex; gap:10px; justify-content:center }
.btn-primary{ background:#1976d2; color:#fff; border:none; padding:10px 14px; border-radius:8px; cursor:pointer }
.btn-ghost{ background:#fff; color:#333; border:1px solid #cfd8dc; padding:10px 14px; border-radius:8px; cursor:pointer }
@media (max-width:420px){ :root{--card-w:96px;--card-h:114px} .card svg{ width:64px } .modal h2{ font-size:20px } }
</style>
</head>
<body>
<h1>單只因 Set</h1>
<div id="controls">
<button id="startBtn">開始遊戲</button>
<button id="resetBtn">重新開始</button>
<button id="hintBtn">提示 (顯示一組)</button>
<span id="timer">00:00</span>
<span id="score">分數: 0</span>
</div>
<div id="game">
<div class="board" id="board"></div>
<div style="margin-top:10px"><button id="dealMore" style="display:none">補牌</button></div>
</div>
<div id="scoreboard">
<h2>歷史紀錄</h2>
<table>
<thead><tr><th>日期</th><th>時間</th><th>分數</th><th>正確</th><th>錯誤</th></tr></thead>
<tbody id="history"></tbody>
</table>
<div style="margin-top:8px"><button id="clearHistory">清除紀錄</button></div>
</div>
<svg style="position:absolute; width:0; height:0;" aria-hidden="true">
<defs>
<pattern id="str-red" patternUnits="userSpaceOnUse" width="8" height="8" patternTransform="rotate(45)">
<rect width="100%" height="100%" fill="transparent"></rect>
<path d="M0 0 L0 8" stroke="#b71c1c" stroke-width="2" stroke-linecap="square"></path>
</pattern>
<pattern id="str-green" patternUnits="userSpaceOnUse" width="8" height="8" patternTransform="rotate(45)">
<rect width="100%" height="100%" fill="transparent"></rect>
<path d="M0 0 L0 8" stroke="#004d40" stroke-width="2" stroke-linecap="square"></path>
</pattern>
<pattern id="str-purple" patternUnits="userSpaceOnUse" width="8" height="8" patternTransform="rotate(45)">
<rect width="100%" height="100%" fill="transparent"></rect>
<path d="M0 0 L0 8" stroke="#9c27b0" stroke-width="2" stroke-linecap="square"></path>
</pattern>
</defs>
</svg>
<div id="modalRoot" style="display:none"></div>
<script>
const MAX_SLOTS = 18;
let deck = [], boardSlots = Array(MAX_SLOTS).fill(null), selected = [];
let score = 0, correct = 0, wrong = 0;
let timerInterval = null, startTime = null;
let newIndices = [];
let gameOver = false;
const shapes = ["oval","diamond","squiggle"];
const fills = ["solid","striped","open"];
const colors = ["red","green","purple"];
const colorHex = { red:'#b71c1c', green:'#004d40', purple:'#9c27b0' };
const boardEl = document.getElementById('board');
const scoreEl = document.getElementById('score');
const timerEl = document.getElementById('timer');
const dealBtn = document.getElementById('dealMore');
const startBtn = document.getElementById('startBtn');
const resetBtn = document.getElementById('resetBtn');
const hintBtn = document.getElementById('hintBtn');
const modalRoot = document.getElementById('modalRoot');
startBtn.addEventListener('click', startGame);
resetBtn.addEventListener('click', ()=>{ stopTimer(); startGame(); });
dealBtn.addEventListener('click', ()=>{ dealMore(true); });
hintBtn.addEventListener('click', showHint);
document.getElementById('clearHistory').addEventListener('click', clearHistory);
boardEl.addEventListener('pointerdown', (e)=>{
  const cardDiv = e.target.closest('.card');
  if (!cardDiv) return;
  const idx = Number(cardDiv.dataset.index);
  if (isNaN(idx)) return;
  if (gameOver) return;
  if (!boardSlots[idx]) return;
  e.preventDefault();
  toggleSelect(idx);
});
function makeDeck(){
  const d=[];
  for(let num=1;num<=3;num++){
    for(let shape of shapes){
      for(let fill of fills){
        for(let color of colors){
          d.push({id:`${num}-${shape}-${fill}-${color}`, num,shape,fill,color});
        }
      }
    }
  }
  return shuffle(d);
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function startGame(){
  deck = makeDeck();
  boardSlots = Array(MAX_SLOTS).fill(null);
  for(let i=0;i<12;i++) boardSlots[i]=deck.pop();
  selected=[]; score=0; correct=0; wrong=0; gameOver=false;
  scoreEl.innerText='分數: 0'; newIndices=[...Array(12).keys()]; startTimer(); render(); ensureSetOrExhaust(); hideModal();
}
function render(){
  boardEl.innerHTML='';
  for(let idx=0;idx<MAX_SLOTS;idx++){
    const card = boardSlots[idx];
    const div = document.createElement('div');
    div.className = card?'card':'card empty';
    if(newIndices.includes(idx)) div.classList.add('new');
    if(selected.includes(idx)) div.classList.add('selected');
    div.dataset.index=idx;
    div.innerHTML = card?cardHtml(card):'';
    if(card) div.addEventListener('click', ()=>{ if(!gameOver && boardSlots[idx]) toggleSelect(idx); });
    boardEl.appendChild(div);
  }
  setTimeout(()=>{ newIndices=[]; }, 360);
  checkDealMore();
}
function toggleSelect(idx){
  if(selected.includes(idx)) selected=selected.filter(x=>x!==idx);
  else selected.push(idx);
  const node=boardEl.querySelector(`.card[data-index='${idx}']`);
  if(node) node.classList.toggle('selected', selected.includes(idx));
  if(selected.length===3) handleThreeSelected();
}
function handleThreeSelected(){
  const cards = selected.map(i=>boardSlots[i]);
  const selectedNodes = Array.from(boardEl.querySelectorAll('.card')).filter(n=>selected.includes(Number(n.dataset.index)));
  if(isSet(cards)){
    selectedNodes.forEach(n=>n.classList.add('removing'));
    setTimeout(()=>{
      selected.forEach(i=>boardSlots[i]=null);
      fillToMinimum();
      score++; correct++; scoreEl.innerText='分數: '+score;
      selected=[];
      render();
      ensureSetOrExhaust();
      checkEnd();
    },320);
  } else {
    selectedNodes.forEach(n=> n.animate([{transform:'translateY(0)'},{transform:'translateY(-6px)'},{transform:'translateY(0)'}],{duration:260}));
    wrong++;
    scoreEl.innerText='分數: '+score;
    setTimeout(()=>{ selected=[]; render(); }, 260);
  }
}
function cardHtml(c){
  const hex=colorHex[c.color]||'#000';
  const fill=(c.fill==='solid')?hex:(c.fill==='striped'?`url(#str-${c.color})`:'none');
  const stroke=hex;
  let svgW=72; const svgH=(c.num===1)?36:(c.num===2)?30:24;
  let shapeSvg='';
  if(c.shape==='oval') shapeSvg=`<svg viewBox="0 0 100 40" preserveAspectRatio="xMidYMid meet" style="width:${svgW}px;height:${svgH}px"><ellipse cx="50" cy="20" rx="38" ry="14" fill="${fill}" stroke="${stroke}" stroke-width="2"/></svg>`;
  else if(c.shape==='diamond') shapeSvg=`<svg viewBox="0 0 100 60" preserveAspectRatio="xMidYMid meet" style="width:${svgW}px;height:${svgH}px"><polygon points="50,6 94,30 50,54 6,30" fill="${fill}" stroke="${stroke}" stroke-width="2"/></svg>`;
  else shapeSvg=`<svg viewBox="0 0 120 48" preserveAspectRatio="xMidYMid meet" style="width:${svgW}px;height:${svgH}px"><path d="M8 24 C18 6,38 6,48 24 C58 42,78 42,88 24 C98 6,118 6,112 24 C106 42,86 42,76 24 C66 6,46 6,36 24 C26 42,6 42,8 24 Z" fill="${fill}" stroke="${stroke}" stroke-width="2"/></svg>`;
  let items='';
  for(let i=0;i<c.num;i++) items+=`<div style="margin:2px 0">${shapeSvg}</div>`;
  return `<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%">${items}</div>`;
}
function isSet(cards){ function allSameOrAllDiff(a,b,c){return(a===b&&b===c)||(a!==b&&b!==c&&a!==c);} return allSameOrAllDiff(cards[0].num,cards[1].num,cards[2].num)&&allSameOrAllDiff(cards[0].shape,cards[1].shape,cards[2].shape)&&allSameOrAllDiff(cards[0].fill,cards[1].fill,cards[2].fill)&&allSameOrAllDiff(cards[0].color,cards[1].color,cards[2].color); }
function fillToMinimum(){ let active=boardSlots.filter(x=>x).length; for(let i=0;i<MAX_SLOTS && active<12;i++){ if(!boardSlots[i] && deck.length>0){ boardSlots[i]=deck.pop(); newIndices.push(i); active++; } } }
function dealMore(forced=false){ if(forced){ let added=0; for(let i=0;i<MAX_SLOTS;i++){ if(!boardSlots[i] && deck.length>0){ boardSlots[i]=deck.pop(); newIndices.push(i); added++; } } render(); ensureSetOrExhaust(); } }
function showHint(){ const s=findAnySet(); if(s){ s.forEach(i=>{ const n=boardEl.querySelector(`.card[data-index='${i}']`); if(n) n.classList.add('hint'); setTimeout(()=>n.classList.remove('hint'),800); }); } }
function findAnySet(){ for(let i=0;i<MAX_SLOTS-2;i++){ if(!boardSlots[i]) continue; for(let j=i+1;j<MAX_SLOTS-1;j++){ if(!boardSlots[j]) continue; for(let k=j+1;k<MAX_SLOTS;k++){ if(!boardSlots[k]) continue; if(isSet([boardSlots[i],boardSlots[j],boardSlots[k]])) return [i,j,k]; } } } return null; }
function ensureSetOrExhaust(){ if(!findAnySet() && deck.length>0) dealMore(true); }
function checkDealMore(){ dealBtn.style.display=(deck.length>0 && boardSlots.filter(x=>x).length<MAX_SLOTS)?'inline-block':'none'; }
function startTimer(){ startTime=Date.now(); if(timerInterval) clearInterval(timerInterval); timerInterval=setInterval(()=>{ const diff=Math.floor((Date.now()-startTime)/1000); timerEl.innerText = `${String(Math.floor(diff/60)).padStart(2,'0')}:${String(diff%60).padStart(2,'0')}`; },1000); }
function stopTimer(){ if(timerInterval) clearInterval(timerInterval); timerInterval=null; }
function checkEnd(){ if(!findAnySet() && deck.length===0){ gameOver=true; stopTimer(); showModal(`遊戲結束！`,`分數: ${score}<br>正確: ${correct}<br>錯誤: ${wrong}`); saveHistory(); } }
function showModal(title, content){ modalRoot.innerHTML=`<div class="modal-backdrop"><div class="modal"><h2>${title}</h2><p>${content}</p><div class="actions"><button class="btn-primary" onclick="hideModal();startGame()">再玩一次</button></div></div></div>`; modalRoot.style.display='block'; }
function hideModal(){ modalRoot.style.display='none'; modalRoot.innerHTML=''; }
function saveHistory(){ const tbody=document.getElementById('history'); const now=new Date(); const tr=document.createElement('tr'); tr.innerHTML=`<td>${now.toLocaleDateString()}</td><td>${now.toLocaleTimeString()}</td><td>${score}</td><td>${correct}</td><td>${wrong}</td>`; tbody.prepend(tr); }
function clearHistory(){ document.getElementById('history').innerHTML=''; }
</script>
</body>
</html>

